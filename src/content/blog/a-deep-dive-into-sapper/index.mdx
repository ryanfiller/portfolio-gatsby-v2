---
title: A Deep Dive into Sapper
options:
  published: false
  customurl: ''
  customtemplate: ''
meta:
  date: 2020-06-15T23:13:49.134Z
  excerpt: Exploring some of the more esoteric details about Svelte and Sapper
  categories:
    - code
  tags:
    - svelte
    - sapper
---
Svelte is a Javascript framework that has been interesting to me since seeing [Nate Clark](https://nateclark.io/) give a short talk on it at my [local meetup](https://memphiswebworkers.com/) last summer. I built a really basic color app ([demo](https://rgb-color-values.netlify.app/), [code](https://github.com/ryanfiller/rgb-color-values)) around the same time and haven't touched Svelte much since then. A lot has changed since then, both in the world and with the framework - [Svelte 3](https://svelte.dev/blog/svelte-3-rethinking-reactivity) was released earlier this year - and I thought it was time to take another look at both Svelte its application framework, [Sapper](https://sapper.svelte.dev/).

## What is Svelte and what is Sapper?

[Svelte](https://svelte.dev/) is a new-ish framework that takeas a "radical new approach to building user interfaces." Svelte differs from other Javascript UI tools, like [React](https://reactjs.org/) or [Vue](https://vuejs.org/), in that it does its work during compile time rather than in the browser. This means that rather than ship the library itself, Svelte "boils away" and only vanilla Javascript makes it to the browser.

This video sums up the philosphy behind Svelte: https://www.youtube.com/watch?v=AdNJ3fydeao

[Sapper](https://sapper.svelte.dev/) is Svelte's first party application framework, akin to [Create React App](https://reactjs.org/docs/create-a-new-react-app.html#create-react-app) or [Next](https://nextjs.org/) for React, or or [Nuxt](https://nuxtjs.org/) for Vue. Sapper is also able to export a static version of a site, putting it more in line with [Gatsby](https://www.gatsbyjs.org/) for React and [Gridsome](https://gridsome.org/) for Vue.

## ??? Headlines are hard....

I've been working in the Gatsby-React ecosystem for a while, and I've formed pretty strong opinions about how I like to do things such as organize files, which toolschains I use, plugins I can't live without, etc. Obvioulys Sapper could be used to make *a* markdown blog, but it could make one the *I* wanted? I know that no two frameworks will ever be completely 1:1 with each other, but I started by making a list of must-have features:

TODO: link these to the headres down below

* Works With No Client JS
* Global Components
* JavaScript in Markdown
* Automatic Markdown Processing
* Colocation of Images & Components
* post/index File Structure
* Inline SVGs
* SCSS Imports
* Easy RSS Feed & Sitemap

I put together a [quick starter project](https://github.com/ryanfiller/sapper-test) and hosted it on [Netlify](https://sapper-goals.netlify.app/) to get my hands dirty and try to accomplish all of these things and see how much friction implementing them in Sapper would cause. 

(Spoilers: it did everything I wanted, and was relatvively easy along the way.)

## Works With No Client JS

Sapper, like most other Javascript Static Site Generators, works by building a server side HTML bundle and then rehydrating it by re-rendering on top of it clientside with Javascript. Sapper's production script comes in two versions, \`build\` and \`export\`. \`build\` will generate a Node app that can be hosted somewhere, and \`export\` will generate a static version of the site.

\> Static doesn't mean non-interactive â€” your Svelte components work exactly as they do normally, and you still get all the benefits of client-side routing and prefetching.

The great news is that this feature works by default. If for whatever reason a user has Javascript disabled in their browser, they get the un-hydrated version of the Sapper app and, assuming everything was build in a smart way, the app will work as plain HTML. Sapper doesn't use special components in place of `<a>` tags, so even links will function like regular HTML links.

## Global Components

This is something else that most component-based frameworks offer, but I wanted the ability to re-render only some parts of the page on route changes. Sapper boasts the ability to *"surgically updates the DOM when the state of your app changes",* and the [`_layout.svelte`](``https://sapper.svelte.dev/docs#Layouts) file allows for just that. `_layout.svelte` is a file that will accept the contents of any other page into the `<slot/>` tag, which means that anything outside that tag will persist between pages. Sapper also will automatically proved a `segment` prop that can be used to determind what the current page is or even conditionally render nested routes. 

From the header component I put together:

```svelte
// nav.svelte
<script>
  export let active
</script>

<style>
  a {
    color: currentColor;
  }
  a.active {
    font-weight: bold;
    color: orange;
    border-bottom: 2px solid orange;
  }
</style>

<nav class='main-nav'>
  <ul>
    <li>
      <a href='/' class={!segment ? 'active' : ''}>
        about
      </a>
    </li>
    <li>
      <a href='goals' class={segment === 'goals' ? 'active' : ''}>
        goals
      </a>
    </li>
  </ul>
</nav>
```

## JavaScript in Markdown

This was the first feature that Sapper didn't provide natively. Analogous to [MDX,](https://mdxjs.com/) the Svelte ecosystem has its own Javascrit-Markdown hybrid toold - [MDsveX](https://mdsvex.com/). MDsveX works by transforming markdown into Svelte components, which lets file imports go both ways. `.md` content can be imported into `.svelte` components, and vice versa. MDsveX has to be configured as a plugin in the `rollup.config.js` file in the root of the project, and it can take a number of config optoins to do things like change the default file extension. More importantly, the build scripts in `package.json` need to be modified so that they correctly process whichever file extension are specified in the config.

```javascript
"dev": "sapper dev --ext '.svelte .md'",
"build": "sapper build --legacy --ext '.svelte .md'",
"export": "sapper export --legacy --ext '.svelte .md'"
```

With this preprocessing set up to happen during Svelte's complie time, components can be important into markdown files and used inline. Data from the posts frontmatter is even automatically parsed and passed into the pages as props.

```markdown
---
title: a post
---

<script>
  import Component from './_component.svelte'
</script>

# Regular Markdown

<Component text={title} />
```

## Automatic Markdown Processing

Moreso than using components in Markdown I use MDX to build automatically rendered, extra-powered versions of regular HTML components. I'm of the strong opinion that my content should be able to be rendered by a regular Markdown parser into regular HTML first, but that I should be able to use other tools to add functionality on top of it. I usually use [data attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/data-*) to do this, 

```html
<img src="image.jpg" alt="title" data-align="right" />
```

MDsveX, by design, will only process Markdown content and not any inline HTML. This means that in order to add any attributes other than `src` and `alt` to images I needed to figure out a way to extend default Markdown functionality. Luckily, MDsveX recently reached version 0.8 and added the ability to use [remark plugins](https://github.com/remarkjs/remark/blob/master/doc/plugins.md), and there happens to be [a plugin](https://github.com/arobase-che/remark-attr) to do exactly that. Once the [remark-attr](https://github.com/arobase-che/remark-attr) pluging is configured in the `remarkPlugins` array in `rollup.config.js` any extra attributes can be added in markdown, and will be ignored in parsers that do not support this functionality.

```markdown
![title](image.jpg){align="right"}
```

MDsveX can also be configured with a module script in each layout with an object containing components that will automatically be replaced when the corresponding HTML is rendered by that layout.

```svelte
<script context="module">
  import { h1, img } from './components.js';
  export { h1, img };
</script>
```

## Colocation of Images & Components

asdf

## post/index File Structure

asdf

## Inline SVGs

asdf

## SCSS Imports

asdf

## Easy RSS Feed & Sitemap

asdf

Huge thank you to [pngwn](https://twitter.com/evilpingwin), the creator of MDsveX, for helping me get that running correctly on my demo site.