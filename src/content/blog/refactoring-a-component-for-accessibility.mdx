---
title: Refactoring a Component for Accessibility
options:
  customtemplate: ''
  customurl: ''
  published: false
meta:
  categories:
    - code
  date: 2020-02-08T16:15:49.682Z
  excerpt: TODO
  tags:
    - accessibility
    - ARIA
---
A few months ago when I decided to start my website from scratch I decided I would also keep a detailed [change log](/changes). This was meant to track the progression of my code, but also my thought process of *why* I was adding things. The version names are completely arbitrary, but I thought it might be fun to name them after [giant robots from the Gudam UC timeline](https://gundam.fandom.com/wiki/RX-78_Gundam_Series) since in universe those follow some semblance of [semantic versioning](https://semver.org/), and I am also a huge dork.

Pretty soon this page got long, and I wanted to add a basic accordion feature to it - each change set would have a header and a summary, and the details of what was changed would be collapsable. My component was built in React, but the idea is pretty universal. A button would toggle between the open and closed state, that state would be reprsented by a class on the wrapping element. CSS would use that class to determine when to show the details.

```javascript
const Change = props => {

  const [state, toggleOpen] = useState(false)

  return (
    <section className={'change', open ? 'open' : ''}>
      <h2>{change title}</h2>
      <p>{summary text}</p>
      <ul>
        {...a list of changes}
      </ul>
      <button 
        onClick={() => toggleOpen(!open)}
      >
        Read {!open ? 'More' : 'Less'}...
      </button>
    </section>
  )
}
```

The styles were also pretty simple.

```scss
.change {
  ul {
    max-height: 0;
    overflow: hidden;
    transition: .2s;
  }

  &.open {    
    ul {
      max-height: 100vh;
    }
  }
}
```

## Good Intentions

Reading that code I know it might not seem like it, but I care about accessibility. I really do. I did some quick searching and I found the [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) [`role="switch"`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/Switch_role) and added that to my button, because hey, the button is switching between an "on" and "off" state.

```javascript
<button 
  onClick={handleToggleOpen}
  role="switch"
  aria-checked={open}
>
  Read {!open ? 'More' : 'Less'}...
</button>
```

Because I do care about accessbility, and it is hard, I use a tool in my testing suite called [Jest aXe](https://www.npmjs.com/package/jest-axe). I know it says in big, bold letters at the top of the page that "this project does not guarantee what you build is accessible," but the code I had written passed an automated test.

```javascript
describe('<Change/>', () => {
  it('should render correctly', async () => {
    const component = mount(<Chage {...props} />)
    expect(await axe(component.html())).toHaveNoViolations()
  })
})
```

## *Actually* Making The Component Accessible

After more reading, there are several things wrong with the component.

* The button is not linked in any way with the section that it controls.
* There are no attributes on the `<section>` element indicating the open/closed state.
* The hidden section is only hidden with css, there is nothing in the markup to indicate whether or not it is visible.

An actually accessible implementation would have needed to look something more like this.

```javascript
const Change = props => {

  const [state, toggleOpen] = useState(false)

  return (
    <section 
      className={'change', open ? 'open' : ''}
      id="toggle-section"
      aria-expanded={open}
    >
      <h2>{change title}</h2>
      <p>{summary text}</p>
      <ul
        aria-hidden={!open}
      >
        {...a list of changes}
      </ul>
      <button 
        onClick={() => toggleOpen(!open)}
        role="switch"
        aria-checked={open}
        id="toggle-button"
        aria-controls="toggle-section"
      >
        Read {!open ? 'More' : 'Less'}...
      </button>
    </section>
  )
}
```

This isn't an unbearable amount of changes, but it was enough that I was nervous to mess it up and still miss something. Also each `id` would need be unique to that instance of the `<Change>` component. In my experience, the best way to make something accessible and repeatable was to make it as automatic as possible, and my data wasn't set up in a way that would make that easy to do.

## There Has to Be an Easier Way?

HTML5 brought with it a ton of [semantic elements](https://developer.mozilla.org/en-US/docs/Glossary/Semantics#Semantic_elements). These are native browser elements that come with inherent meaning attached to their usage. Most people are probably familiar with some of the oldest semantic elements, like `<h1>,` `<p>`, `<ol>`, or even some of the newer ones like `<header>`, `<footer>`, or `<nav>`. There is actually a set of elements that was made for *exactly* what I'm trying to do here - [`<details>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/details) and [`<summary>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/summary).

> The **HTML Details Element (`<details>`)** creates a disclosure widget in which information is visible only when the widget is toggled into an "open" state. A summary or label can be provided using the [`<summary>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/summary "The HTML Disclosure Summary element (\<summary>) element specifies a summary, caption, or legend for a \<details> element's disclosure box.") element.

There are a lot of great articles (I like [this one](https://css-tricks.com/why-how-and-when-to-use-semantic-html-and-aria/) a lot) about ARIA vs native semantic elements, but they all basically drive home this one point - you don't have to fight against what browsers program native elements to do.

```html
<div role="heading" aria-level="1">This is not incorrect..</div>

<h1>...but this is better. And more simple.</h1>
```
